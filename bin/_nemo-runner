#!/usr/bin/env node
'use strict';


/**
 * Module dependencies.
 */

let program = require('commander');
const path = require('path');
const fs = require('fs');
const spawn = require('threads').spawn;
const Nemo = require('nemo');
const cwd = process.cwd();
const glob = require('glob');
const instance = require('../lib/instance');
const async = require('async');
const merge = require('lodash.merge');
const debug = require('debug');
const log = debug('nemo-runner:log');
const error = debug('nemo-runner:error');

function list(val) {
  return val.split(',');
}
function cwdPath(rel) {
  return path.resolve(cwd, rel);
}
program
  .version(JSON.parse(fs.readFileSync(path.join(__dirname, '..', 'package.json'), 'utf8')).version)
  .usage('[options]')
  .option('-B, --base-directory <path>', 'parent directory for config/ and spec/ (or other test file) directories. relative to cwd', cwdPath)
  .option('-P, --profile [profile]', 'which profile(s) to run, out of the configuration', list)
  .option('-G, --grep <pattern>', 'only run tests matching <pattern>', list)
  // .option('-F, --file ', 'run parallel by file')
  .option('--debug-brk', 'enable node\'s debugger breaking on the first line')
  .option('--inspect', 'activate devtools in chrome')
  .option('--no-timeouts', 'remove timeouts in debug/inspect use case')
  .parse(process.argv);
program._name = 'nemo-runner';
Nemo.Configure(program.baseDirectory, {}).then(function (config) {
  let base = config.get('profiles:base');
  let profiles = program.profile;
  let greps = program.grep || '';
  let results = [];

  profiles = (profiles instanceof Array) ? profiles : [profiles];
  greps = (greps instanceof Array) ? greps : [greps];
  let profilesConf = [];
  profiles.forEach(function (profile) {
    greps.forEach(function (grep) {
      let profileConf = merge(merge({}, base), config.get(`profiles:${profile}`));
      let profileLabel = `profile: ${profile || 'default'}`;
      profileLabel = profileLabel + ((grep !== '') ? `, grep: ${grep}` : '');
      profileConf.profileLabel = profileLabel;
      if (!program.timeouts) {
        profileConf.mocha.timeout = 1200000;
      }
      if (grep !== '') {
        profileConf.mocha.grep = grep;
      }
      if (profileConf.mocha && profileConf.mocha.reporterOptions && profileConf.mocha.reporterOptions.reportFilename && grep !== '') {
        // customize report filename
        profileConf.mocha.reporterOptions.reportFilename = `${profileConf.mocha.reporterOptions.reportFilename}.${grep}`;
      }
      profilesConf.push(profileConf);
    });
  });
  let testFileGlobs = profilesConf.map(function (pconf) {
    return function (cb) {
      let testFileGlob = path.resolve(program.baseDirectory, pconf.tests);
      glob(testFileGlob, {}, function (err, files) {
        if (err) {
          return cb(err);
        }
        pconf.tests = files;
        cb(null, pconf);
      });
    };
  });
  async.parallel(testFileGlobs, function (err, profileConfs) {
    if (err) {
      error(err);
      process.exit();
    }
    log('result of async', profileConfs);
    if (profileConfs.length === 1) {
      // TODO: the below doesn't work. not sure we can move env vars up to parent process
      // process.env = Object.assign({}, process.env, profileConfs[0].env || {});
      return instance({basedir: program.baseDirectory, profile: profileConfs[0] || 'default'});
    }
    // parallel use case
    let complete = 0;
    profileConfs.forEach(function (profileConf) {
      // let kv = {};
      // Object.keys(process.env).forEach(function ())
      const thread = spawn(instance, {env: Object.assign({}, process.env, profileConf.env || {})});

      thread
        .send({basedir: program.baseDirectory, profile: profileConf})
        // The handlers come here: (none of them is mandatory)
        .on('message', function (summary) {
          log('Thread complete', summary);
          results.push(summary);
          thread.kill();
        })
        .on('error', function (er) {
          error(er);
        })
        .on('exit', function () {
          complete = complete + 1;
          thread.removeAllListeners('message');
          thread.removeAllListeners('error');
          thread.removeAllListeners('exit');
          if (complete === profileConfs.length) {
            let totals = {label: 'TOTAL', total: 0, pass: 0, fail: 0};
            log('Everything done, shutting down the thread pool.');
            results.forEach(function (result) {
              totals.total = totals.total + result.total;
              totals.pass = totals.pass + result.pass;
              totals.fail = totals.fail + result.fail;
            });
            results.push(totals);
            /* eslint-disable */
            console.log(results);
            /* eslint-enable */
          }
        });
    });
  });
});
